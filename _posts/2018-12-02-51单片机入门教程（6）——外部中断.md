---

title: 51单片机入门教程(6) —— 外部中断

layout: post

author: GYC

tags: 单片机


---      


# 51单片机入门教程（6）——外部中断

## 一、外部中断

### 1.1 中断
关于中断的概念在上一篇博客中已经提到了。（传送门：[51单片机入门教程（5）——定时器中断](https://blog.csdn.net/qq_19799765/article/details/84501917)）    
> 中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。    

51单片机的中断源优先级与向量号如下表：    


中断源  |  优先级  |  中断向量号
--------- | --------- | ------------------
INT0 -- 外部中断0 | 最高 | 0
T0 -- 定时器/计数器0中断 | 第2 | 1
INT1 -- 外部中断1 | 第3 | 2
T1 -- 定时器/计数器1中断 | 第4 | 3
串口中断 | 第5 | 4
T2 -- 定时器/计数器2中断 | 最低 | 5



### 1.2 外部中断
除了定时器中断外，51单片机还有**两个外部中断源**——外部中断0、外部中断1。分别由单片机的12号引脚（INT0/P3.2）、13号（INT1/P3.3）引脚的**低电平/负跳变**触发。
![图片](https://raw.githubusercontent.com/ChasorG/ChasorG.github.io/master/_posts/181202/1.png)
和定时器中断一样，要使用这两个外部中断，首先要进行初始化操作，即写入相关的寄存器。初始化外部中断需要写入下面两个寄存器。
> 1、IE – 中断允许控制寄存器     
> 2、TCON – 控制寄存器    

以初始化0号外部中断为例，说明寄存器的设置方法。

- IE 中断允许控制寄存器   

序号 | D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 
----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- 
符号 | EA | -- | ET2 | ES | ET1 | EX1 | ET0 | EX0 



说明：    
**EA** 全局中断允许位，当此位是1时中断可用。**（重要）**        
**ET2** 定时器/计数器2中断允许位            
**ES**  串口中断允许位        
**ET1** 定时器/计数器1中断允许位        
**EX1** 外部中断1允许位        
**ET0** 定时器/计数器0中断允许位 
**EX0** 外部中断0允许位 **（重要）**           
和定时器中断类似，使用外部中断需要开启全局中断允许位`EA`，以及开启外部中断0允许位`EX0`

```clike
EA = 1;     //开启总中断
EX0 = 1;	 //开启0号外部中断
```

- TCON 控制寄存器    

序号 | D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 
----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- 
符号 | TF1 | TR1 | TF0 | TR0 | IE1 | IT1 | IE0 | IT0

说明：
**TF1** 定时器1溢出标志位
**TR1** 定时器1运行控制位
**TF0** 定时器0溢出标志位
**TR0** 定时器0运行控制位
**IE1 外部中断1请求标志**  IE1=1则**外部中断1在向CPU请求中断**，当CPU响应中断时硬件清0。一般不用手动设置。
**IT1 外部中断1触发方式选择位** 该位为0时INT1引脚上的**低电平信号**可触发外部中断1。该位为1时INT1引脚上的**负跳变信号**可触发外部中断1。
**IE0 外部中断0请求标志**  IE0=1则**外部中断0在向CPU请求中断**，当CPU响应中断时硬件清0。一般不用手动设置。
**IT0 外部中断0触发方式选择位** 该位为0时INT0引脚上的**低电平信号**可触发外部中断1。该位为1时INT1引脚上的**负跳变信号**可触发外部中断1。**（重要）**   

IE1和IE0为状态位，即表示CPU对当前的中断执行状态，一般无需手动设置。需要设置的寄存器位是`IT0`，以选择**低电平信号触发**还是**负跳变信号触发**。    
> **低电平信号** ：即该引脚电平信号为0时有效。    
> **负跳变信号** ：意思是电平从高跳至低时有效，即1→0的信号，而一直维持低电平则不会触发中断。    

```clike
IT0 = 1;	 //设置外部中断触发方式 
```

由以上内容可知，如果要使用外部中断0，并设置为负跳变信号触发，程序写法如下：

```clike
void initEx0() {
  //中断允许寄存器IE
  EA = 1;	 //开启总中断
  EX0 = 1;	 //开启0号外部中断
  //控制寄存器TCON
  IT0 = 1;	 //设置外部中断触发方式 
             //0 - 低电平触发
             //1 - 负跳变触发
}
```
假如要实现以下功能：
> 按键与INT0引脚相连，按下按键触发外部中断。     
> 每触发一次外部中断，计数加一，并将次数显示在一位数码管上。

搭建仿真电路如下：
![图片](https://raw.githubusercontent.com/ChasorG/ChasorG.github.io/master/_posts/181202/2.png)
代码如下：

```clike
## include <reg52.h>
## define uchar unsigned char
## define uint unsigned int

//共阳数码管编码表
uchar code table[] =
{0xc0,0xf9,0xa4,0xb0,
0x99,0x92,0x82,0xf8,
0x80,0x90,0x88,0x83,
0xc6,0xa1,0x86,0x8e};

//初始化0号外部中断
void initEx0();

//计数变量
uint count = 0;

void main()
{
  initEx0();
  while(1){
    P2 = table[count];   //在数码管上显示中断次数
  }
}

void initEx0() {
  EA = 1;	 //开启总中断
  EX0 = 1;	 //开启0号外部中断
  IT0 = 1;	 //设置外部中断触发方式 
             //0 - 低电平触发
             //1 - 负跳变触发
}

void ex0_intr() interrupt 0 { 
  //每进入一次中断，则次数加一
  count = count + 1;
  if(count == 10)
    count = 0;
}
```
## 二、中断优先级
51单片机的中断系统有6个中断源，可实现二级中断嵌套 。     
再次放出这张表       

 中断源  |  优先级  |  中断向量号
--------- | --------- | ------------------
INT0 -- 外部中断0 | 最高 | 0
T0 -- 定时器/计数器0中断 | 第2 | 1
INT1 -- 外部中断1 | 第3 | 2
T1 -- 定时器/计数器1中断 | 第4 | 3
串口中断 | 第5 | 4
T2 -- 定时器/计数器2中断 | 最低 | 5

假设外部中断0、1同时向CPU申请中断，由上表可知，优先执行0号外部中断的服务程序。    
修改仿真电路如下（按键同时连接INT0与INT1）。按键按下，则CPU同时收到两个中断请求：
![图片](https://raw.githubusercontent.com/ChasorG/ChasorG.github.io/master/_posts/181202/3.png)

修改程序功能如下：
> 在0号外部中断服务程序中数码管**显示0**      
> 在1号外部中断服务程序中数码管**显示1**    

代码如下

```clike
## include <reg52.h>
## define uchar unsigned char
## define uint unsigned int

//共阳数码管编码表
uchar code table[] =
{0xc0,0xf9,0xa4,0xb0,
0x99,0x92,0x82,0xf8,
0x80,0x90,0x88,0x83,
0xc6,0xa1,0x86,0x8e};

//初始化0、1号外部中断
void init();

void main()
{
  init();
  while(1);  //等待中断发生
}

void init() {
  EA = 1;	 //开启总中断
  EX0 = 1;	 //开启0号外部中断
  IT0 = 1;	 //设置外部中断触发方式 
  EX1 = 1;   //1号外部中断
  IT1 = 1;
}

void ex0_intr() interrupt 0 { 
  P2 = table[0];  //显示0
}

void ex1_intr() interrupt 2 { 
  P2 = table[1];  //显示1
}
```
编译程序，并下载进仿真.按下按键即可看到**数码管显示1**，说明当两个外部中断同时向CPU请求中断时，CPU优先处理中断优先级高的那个，即0号外部中断。
![图片](https://raw.githubusercontent.com/ChasorG/ChasorG.github.io/master/_posts/181202/4.png)